use anyhow::{anyhow, Result};
use forc_pkg::{manifest::ManifestFile, BuildPlan, Edge, NodeIx};
use petgraph::{stable_graph::NodeIndex, visit::NodeIndexable};
use std::{
    env::current_dir,
    fmt::Display,
    path::{Path, PathBuf},
};

use crate::cmd::Args;

struct PrintableGraph(petgraph::Graph<PrintablePinnedPkg, Edge>);

impl PrintableGraph {
    /// Reads the `StableGraph` from build plan and converts that into `Graph` while wrapping nodes
    /// in a printable type.
    ///
    ///
    /// The reason we need this wrapper:
    ///
    /// ptree requires using `Graph` and does not accept `StableGraph` input. This requires us to
    /// convert the `StableGraph` given by `forc-pkg` to `Graph`. Also to be able to print with
    /// `ptree::print_graph` we need nodes to implement `fmt::Display`, which is not the case for
    /// `forc_pkg::Pinned` so we need wrap nodes into a printable node wrapper
    /// (`PrintablePinnedPkg`).
    fn from_build_plan(build_plan: &BuildPlan) -> Result<Self> {
        let graph = build_plan.graph();
        let mut new_graph = petgraph::Graph::with_capacity(graph.node_count(), graph.edge_count());

        // A map between node's index in the old graph to its index in the new graph.
        let mut node_index_map = vec![NodeIndex::end(); graph.node_bound()];

        // Converting nodes to printable nodes and keeping track of old index to new index mapping
        // while adding them to new nodes.
        for (i, index) in graph.node_indices().enumerate() {
            let weight = &graph[index];
            let printable_node = PrintablePinnedPkg(weight.clone());
            node_index_map[i] = new_graph.add_node(printable_node);
        }

        // We now have the nodes moved the new graph but we are still missing the edge information. We
        // should be adding them. This is where we are going to be using our lookup map from old index
        // to new index.
        //
        // Basically we will look edges between nodes in the old graph, and find corresponding nodes in
        // the new graph to add the edge between correct nodes.
        for edge in graph.edge_indices() {
            let weight = graph
                .edge_weight(edge)
                .ok_or_else(|| anyhow!("expected edge to have a weight"))?;
            let (source, target) = graph
                .edge_endpoints(edge)
                .expect("expected edge to have a start and and end node.");
            let new_graph_source = node_index_map[source.index()];
            let new_graph_target = node_index_map[target.index()];
            new_graph.add_edge(new_graph_source, new_graph_target, weight.clone());
        }

        Ok(Self(new_graph))
    }

    fn print_tree(&self, start: NodeIndex) -> Result<()> {
        let graph = &self.0;

        Ok(ptree::graph::print_graph(graph, start)?)
    }

    #[cfg(test)]
    fn write_tree<W: std::io::Write>(&self, start: NodeIndex, f: W) -> Result<()> {
        let graph = &self.0;
        let config = ptree::PrintConfig::default();
        Ok(ptree::graph::write_graph_with(graph, start, f, &config)?)
    }
}

/// Generates `forc_pkg::BuildPlan` from given dir.
///
/// This will try to generate the `BuildPlan` with a local IPFS node if there is any IPFS
/// dependencies in the `BuildPlan`.
fn generate_build_plan(dir: &Path, offline: bool) -> Result<BuildPlan> {
    let manifests = ManifestFile::from_dir(dir)?.member_manifests()?;
    let ipfs_node = forc_pkg::source::IPFSNode::Local;
    BuildPlan::from_manifests(&manifests, offline, ipfs_node)
}

#[derive(Clone)]
pub struct PrintablePinnedPkg(forc_pkg::Pinned);

impl Display for PrintablePinnedPkg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let pinned = &self.0;
        let name = &pinned.name;
        let source = &pinned.source;
        write!(f, "name: {name} -- source: {source}")
    }
}

/// Prints the dependency graph using `ptree`.
///
/// Starts the tree from the project node.
fn print_tree_from_root(plan: &BuildPlan) -> Result<()> {
    let printable_graph = PrintableGraph::from_build_plan(plan)?;
    let root_node =
        find_proj_node(plan).ok_or_else(|| anyhow!("Expected plan to have a root node"))?;
    printable_graph.print_tree(root_node)?;
    Ok(())
}

pub fn handle_args(args: Args) -> Result<()> {
    let dir = args
        .path
        .map(PathBuf::from)
        .unwrap_or_else(|| current_dir().unwrap());
    let offline = args.offline;
    let build_plan = generate_build_plan(&dir, offline)?;
    print_tree_from_root(&build_plan)?;
    Ok(())
}

/// Finds the project node in the dependency graph.
///
/// There is a function to do that in forc-pkg which is not exposed. To do so this funciton relies
/// on forc-pkg's compilation order. Compilation order is generated by toposorting the dependency
/// graph and the package node should be the last item in that order.
///
/// This assumption may not hold for workspaces which may requrie changing this to an actual root
/// node searching functionality or exposing forc-pkg's internal root node searcher.
fn find_proj_node(plan: &BuildPlan) -> Option<NodeIx> {
    plan.compilation_order().last().copied()
}

#[cfg(test)]
mod tests {
    use std::{io::Cursor, path::PathBuf};

    use super::{find_proj_node, generate_build_plan, PrintableGraph};

    const TEST_FOLDER: &str = "test";
    const TEST_PROJECT_NAME: &str = "test-project";
    const TEST_LIB_NAME: &str = "test-lib";

    /// Returns the `TEST_PROJECT`'s root directory.
    fn test_project_dir() -> PathBuf {
        let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        root_dir.join(TEST_FOLDER).join(TEST_PROJECT_NAME)
    }

    #[test]
    fn test_generate_build_plan_online() {
        let test_project_dir = test_project_dir();
        let offline = false;

        let build_plan_generated = generate_build_plan(&test_project_dir, offline).is_ok();
        assert!(build_plan_generated)
    }

    #[test]
    fn test_generate_build_plan_offline() {
        let test_project_dir = test_project_dir();
        let offline = true;

        let build_plan_generated = generate_build_plan(&test_project_dir, offline).is_ok();
        assert!(build_plan_generated)
    }

    #[test]
    fn test_generated_dependency_graph() {
        let test_project_dir = test_project_dir();
        let offline = false;

        let build_plan = generate_build_plan(&test_project_dir, offline).unwrap();
        let graph = build_plan.graph();
        let order = build_plan
            .compilation_order()
            .iter()
            .map(|pkg| &graph[*pkg].name)
            .collect::<Vec<_>>();

        let expected_order = vec![TEST_LIB_NAME, TEST_PROJECT_NAME];
        assert_eq!(order, expected_order)
    }

    #[test]
    fn test_print_tree() {
        let test_project_dir = test_project_dir();
        let offline = false;
        let build_plan = generate_build_plan(&test_project_dir, offline).unwrap();
        let printable_plan = PrintableGraph::from_build_plan(&build_plan).unwrap();

        let mut cursor: Cursor<Vec<u8>> = Cursor::new(Vec::new());
        let root_node = find_proj_node(&build_plan).unwrap();
        printable_plan.write_tree(root_node, &mut cursor).unwrap();

        let data = String::from_utf8(cursor.into_inner()).unwrap();
        let expected = "\
                        name: test-project -- source: member\n\
                        └─ name: test-lib -- source: path+from-root-B499DAB0CB6ABDFD\n";
        assert_eq!(data, expected)
    }
}
